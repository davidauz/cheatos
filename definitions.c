#include <windows.h>
#include <stdint.h>
#include "definitions.h"
#include "logic.h"

struct cheat_definition definitions[] =
{	[INFINITE_AMMO]=
	{	"Infinite ammo (numpad 1)"
	,	{0x41, 0x2B, 0xC6	// sub eax,r14d (3)
	,	0x4C, 0x8B, 0x06	// mov r8,[rsi] (3)
	,	0x85, 0xC0	// test eax,eax (2)
	,	0x0F, 0x4F, 0xE8	// cmovg ebp,eax (3)
	,	0x8B, 0xD5	// mov edx,ebp (2)
	,	0x48, 0x8B, 0xCE	// mov rcx,rsi (3)
	,	0x41, 0xFF, 0x90, 0xD8, 0x01, 0x00, 0x00}	// call qword ptr [r8+000001D8] (7)
	,	{ 0x90, 0x90, 0x90 } // nop nop nop
	,	NULL
	,	3
	,	23
	}
,	[INFINITE_AMMO_2]=
	{	"Infinite ammo 2"
	,	{ 0xE8, 0x03, 0x6B, 0xFA, 0xFF // call GenerationZero_F.exe+7181B0 (tutti NOP)
	,	0x84, 0xC0 // test al,al
	,	0x75, 0x0C // jne GenerationZero_F.exe+7716BD
	,	0x48, 0x8B, 0x06 // mov rax,[rsi]
	,	0x48, 0x8B, 0xCE // mov rcx,rsi
	,	0xFF, 0x90, 0x10, 0x02, 0x00, 0x00 // call qword ptr [rax+00000210]
	,	0x48, 0x8B, 0x5C, 0x24, 0x60} // mov rbx,[rsp+60]
	,	{ 0x90, 0x90, 0x90, 0x90, 0x90 } // nop nop nop
	,	NULL
	,	5
	,	26
	}
,	[INFINITE_LIFE]=
	{	"Infinite life (numpad 2)"
	,	{0x40, 0x55 	//	push %rbp 	
	,	0x56 	//	push %rsi
	,	0x57 	//	push %rdi 	
	,	0x41, 0x54 	//	push %r12 	
	,	0x41, 0x55	//	push %r13 	
	,	0x41, 0x56	//	push %r14 	
	,	0x41, 0x57 	//	push %r15 	
	,	0x48, 0x8d, 0xac, 0x24, 0x80, 0xfe, 0xff, 0xff
	,	0x48, 0x81, 0xec, 0x80, 0x02, 0x00, 0x00 	//	sub $0xa0,%rsp 	
	,	0x48, 0xc7, 0x45, 0xc8, 0xfe, 0xff, 0xff, 0xff }	//	movq $0xfffffffffffffffe,-0x1(%rbp) 	
	,	{ 0xc3, 0x90 } // ret nop
	,	NULL
	,	2
	,	35
	}	
//,	[NO_RECHARGE]=
//	{	"" // goes together with infinite ammo
//	,	{ 0x89, 0x91, 0x7c, 0x02, 0x00, 0x00 }
//	,	{ 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 }
//	,	NULL
//	,	6
//	,	6
//	}
,	[INFINITE_STAMINA]=
	{	"Infinite stamina (numpad 3)"
	,	{0x74, 0x45
	,	0x45, 0x33, 0xC9
	,	0xC6, 0x44, 0x24, 0x20, 0x00
	,	0x0F, 0x57, 0xD2 }
	,	{ 0x90, 0x90 }
	,	NULL
	,	2
	,	13
	}
,	[LETS_KILL]=
	{	"Easy kill (numpad 4)"
	,	{ 0xF3, 0x0F, 0x10, 0x83, 0x1C, 0x01, 0x00, 0x00	//	movss  0x11c(%rbx),%xmm0
	,	0x0F, 0x2F, 0xC7	//	comiss %xmm7,%xmm0
	,	0x77, 0x56	//	ja GenerationZero_F.exe+60A673 (2)
	,	0x0F, 0x28, 0xC7	//	comiss %xmm7,%xmm0
	}
	,	{ 0x0F, 0x57, 0xc0  // xorps xmm0,xmm0
	,	0xF3, 0x0F, 0x11, 0x83, 0x1C, 0x01, 0x00, 0x00 //movss [rbx+0000011C],xmm0
	,	0xEB, 0x56} // jmp GenerationZero_F.exe+60A673
	,	NULL
	,	13
	,	16
	}
,	[ZERO_WEIGHT]=
	{	"Zero Weight (numpad 5)"
	,	{0x48, 0x8D, 0x88, 0x38, 0x03, 0x00, 0x00	//	lea rcx,[rax+00000338] (7)
	,	0xE8, 0xD9, 0x28, 0x00, 0x00	//	call GenerationZero_F.exe+722980 (5)
	,	0xF3, 0x0F, 0x11, 0x05, 0x59, 0xEA, 0x3A, 0x02	//	movss [GenerationZero_F.exe+2ACEB08],xmm0 (8)HERE WRITING WEIGHT
	,	0xC6, 0x05, 0xF2, 0x6B, 0x11, 0x02, 0x00}	//	mov byte ptr [GenerationZero_F.exe+2836CA8],00 (7)
	,	{0x0F, 0x57, 0xC0 // xorps xmm0,xmm0
	,	0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 } // nop nop nop ..
	,	NULL
	,	12
	,	27
	}
,	[LETS_FLY]=
	{	"Flying (numpad 6)"
	,	{ 0x0F, 0x29, 0x7F, 0x40  // movaps  xmmword ptr [rdi+40h],xmm7 (movaps %xmm7,0x40(%rdi), 4 bytes)
		, 0x0F, 0x29, 0x77, 0x50 } // movaps  xmmword ptr [rdi+50h],xmm6 (movaps %xmm6,0x50(%rdi), 4 bytes)
	,	{ 0xFF, 0x15, 0x55, 0x0B, 0x84, 0xFE  // call    qword ptr [GenerationZero_F+0x450] ( call   *-0xFE840b55(%rip), 6 bytes)
		, 0x90, 0x90 } // nop nop (and even two bytes to spare)
	,	NULL
	,	8 // total 8 bytes
	,	8 // total 8 bytes
	}
,	[LETS_RUN]=
	{	"Running (numpad 7)"
	,	{ 0xf3, 0x41, 0x0f, 0x10, 0x7e, 0x18 // movss  0x18(%r14),%xmm7 (6b)
		, 0x48, 0x8b, 0x8f, 0xa0, 0x33, 0x00, 0x00 // mov    0x33a0(%rdi),%rcx (7b)
		, 0xe8, 0x8c, 0xae, 0xb9, 0xff, 0x0f } // call   0x7ff7d24407c0 (6b)
	,	{ 0xFF, 0x15, 0x3a, 0xf7, 0xa1, 0xff }  // call qword ptr [GenerationZero_F+0x458] ( 6 bytes)
	,	NULL
	,	6 // code length
	,	19 // aob length
	}
,	[LETS_TICK]=
	{	"Move clock (Numpad 8)"
	,	{ 0x0f, 0x28, 0xce  // movaps %xmm6,%xmm1
		, 0xf3, 0x0f, 0x59, 0x8b, 0xec, 0x00, 0x00, 0x00  //  mulss  0xec(%ebx),%xmm1
		, 0xf3, 0x0f, 0x58, 0xc8 } // addss  %xmm0,%xmm1
	,	{ 0xFF, 0x15, 0xfe, 0xbe, 0xc0, 0xff 		// call qword ptr [GenerationZero_F+0x468] (6 bytes)
		, 0x90, 0x90, 0x90, 0x90, 0x90 			// nop nop nop nop nop (5 bytes)
		, 0x90, 0x90, 0x90, 0x90 }			// nop nop nop nop (4 bytes)
	,	NULL
	,	15					// tot 15 bytes
	,	15					// tot 15 bytes
	}
,	[LAST_ENTRY]=
	{	"Last entry"
	,	{ 0x00, 0x00, 0x00 }
	,	{ 0x00, 0x00, 0x00 }
	,	NULL
	,	0
	}
};


struct cheat_definition *get_definition(int cheat_id) {
	return &definitions[cheat_id];
}

