#include <windows.h>
#include <stdint.h>
#include "definitions.h"
#include "logic.h"

struct cheat_definition definitions[] =
{	[INFINITE_AMMO]=
	{	"Infinite ammo (numpad 1)"
	,	{0x41, 0x2B, 0xC6	// sub eax,r14d (3)
	,	0x4C, 0x8B, 0x06	// mov r8,[rsi] (3)
	,	0x85, 0xC0	// test eax,eax (2)
	,	0x0F, 0x4F, 0xE8	// cmovg ebp,eax (3)
	,	0x8B, 0xD5	// mov edx,ebp (2)
	,	0x48, 0x8B, 0xCE	// mov rcx,rsi (3)
	,	0x41, 0xFF, 0x90, 0xD8, 0x01, 0x00, 0x00}	// call qword ptr [r8+000001D8] (7)
	,	{ 0x90, 0x90, 0x90 } // nop nop nop
	,	NULL
	,	3
	,	23
	}
,	[INFINITE_AMMO_2]=
	{	"Infinite ammo 2"
	,	{ 0xE8, 0x03, 0x6B, 0xFA, 0xFF // call GenerationZero_F.exe+7181B0 (tutti NOP)
	,	0x84, 0xC0 // test al,al
	,	0x75, 0x0C // jne GenerationZero_F.exe+7716BD
	,	0x48, 0x8B, 0x06 // mov rax,[rsi]
	,	0x48, 0x8B, 0xCE // mov rcx,rsi
	,	0xFF, 0x90, 0x10, 0x02, 0x00, 0x00 // call qword ptr [rax+00000210]
	,	0x48, 0x8B, 0x5C, 0x24, 0x60} // mov rbx,[rsp+60]
	,	{ 0x90, 0x90, 0x90, 0x90, 0x90 } // nop nop nop
	,	NULL
	,	5
	,	26
	}
,	[INFINITE_LIFE]=
	{	"Infinite life (numpad 2)"
	,	{0x40, 0x55 	//	push %rbp 	
	,	0x56 	//	push %rsi
	,	0x57 	//	push %rdi 	
	,	0x41, 0x54 	//	push %r12 	
	,	0x41, 0x55	//	push %r13 	
	,	0x41, 0x56	//	push %r14 	
	,	0x41, 0x57 	//	push %r15 	
	,	0x48, 0x8d, 0xac, 0x24, 0x80, 0xfe, 0xff, 0xff
	,	0x48, 0x81, 0xec, 0x80, 0x02, 0x00, 0x00 	//	sub $0xa0,%rsp 	
	,	0x48, 0xc7, 0x45, 0xc8, 0xfe, 0xff, 0xff, 0xff }	//	movq $0xfffffffffffffffe,-0x1(%rbp) 	
	,	{ 0xc3, 0x90 } // ret nop
	,	NULL
	,	2
	,	35
	}	
,	[NO_RECHARGE]=
	{	"" // goes together with infinite ammo
	,	{ 0x89, 0x91, 0x7c, 0x02, 0x00, 0x00 }
	,	{ 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 }
	,	NULL
	,	6
	,	6
	}
,	[INFINITE_STAMINA]=
	{	"Infinite stamina (numpad 3)"
	,	{0x74, 0x45
	,	0x45, 0x33, 0xC9
	,	0xC6, 0x44, 0x24, 0x20, 0x00
	,	0x0F, 0x57, 0xD2 }
	,	{ 0x90, 0x90 }
	,	NULL
	,	2
	,	13
	}
,	[LETS_KILL]=
	{	"Easy kill (numpad 4)"
	,	{ 0xf3, 0x0f, 0x59, 0x53, 0x20 	//	mulss   xmm2,dword ptr [rbx+20h] (5 bytes)
		, 0xf3, 0x0f, 0x59, 0xd0 }	//	mulss   xmm2,xmm0 (4 bytes, tot 9 bytes)
	,	{ 0xFF, 0x15, 0xA6, 0x96, 0x9A, 0xFF  // call qword ptr [GenerationZero_F+0x460] (6 bytes) (0x450+0x10)
		, 0x90, 0x90, 0x90 }		//	nop nop nop (3 bytes)
// \xFF \x15 stands for CALL QWORD PTR [RIP + displacement] or "call through memory pointer".
// What follows the two opcodes is a 32-bit little-endian displacement.
// The target address is calculated as Next RIP + displacement
// where 'Next RIP' is the address of the next instruction after the complete 6-byte call
// So suppose that the instruction starts at: 0x7ff96b304d3d: \xff \x15 11 22 33 44
// The instruction length is of : 6 bytes
// The Next RIP is at 0x7ff96b304d3d + 6 = 0x7ff96b304d43
	,	NULL
	,	9
	,	9
	}
//  p /x 0XFFFFFFFF-(0x656DB4-0x450+5-0x10) =  0xff9a96a6
//           |            |      |  |   |
//           |            |      |  |   +- offset in jump table
//           |            |      |  +- next instruction is 5 bytes down
//           |            |      +- start of jump table
//           |            +- target relative offset
//           +- for negative value
,	[ZERO_WEIGHT]=
	{	"Zero Weight (numpad 5)"
	,	{0x48, 0x8D, 0x88, 0x38, 0x03, 0x00, 0x00	//	lea rcx,[rax+00000338] (7)
	,	0xE8, 0xD9, 0x28, 0x00, 0x00	//	call GenerationZero_F.exe+722980 (5)
	,	0xF3, 0x0F, 0x11, 0x05, 0x59, 0xEA, 0x3A, 0x02	//	movss [GenerationZero_F.exe+2ACEB08],xmm0 (8)HERE WRITING WEIGHT
	,	0xC6, 0x05, 0xF2, 0x6B, 0x11, 0x02, 0x00}	//	mov byte ptr [GenerationZero_F.exe+2836CA8],00 (7)
	,	{0x0F, 0x57, 0xC0 // xorps xmm0,xmm0
	,	0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 } // nop nop nop ..
	,	NULL
	,	12
	,	27
	}
,	[LETS_FLY]=
	{	"Flying (numpad 6)"
	,	{ 0x0F, 0x29, 0x7F, 0x40  // movaps  xmmword ptr [rdi+40h],xmm7 (movaps %xmm7,0x40(%rdi), 4 bytes)
		, 0x0F, 0x29, 0x77, 0x50 } // movaps  xmmword ptr [rdi+50h],xmm6 (movaps %xmm6,0x50(%rdi), 4 bytes)
	,	{ 0xFF, 0x15, 0x55, 0x0B, 0x84, 0xFE  // call    qword ptr [GenerationZero_F+0x450] ( call   *-0xFE840b55(%rip), 6 bytes)
		, 0x90, 0x90 } // nop nop (and even two bytes to spare)
// Here RIP is GenerationZero_F+0x17BF8F5
// Jump table is at GenerationZero_F+0x450; it is filled by init_jump_table() in dll_injection.c
// Jump table address relative to RIP is 0x17BF8F5-0x450+5 = 0x17BF4AA (+5 because RIP points to next instruction)
// But it has to be negative: 0XFFFFFFFF-0x17BF4AA = 0xFE840B55
// So up here is \xFF\x15 (call qword ptr) \x55\x0B\x84\xFE (address location)
// in short: p /x 0XFFFFFFFF-(0x17BF8F5-0x450+5) = 0xFE840B55
	,	NULL
	,	8 // total 8 bytes
	,	8 // total 8 bytes
	}
,	[LETS_RUN]=
	{	"Running (numpad 7)"
	,	{ 0xf3, 0x41, 0x0f, 0x10, 0x7e, 0x18 // movss  0x18(%r14),%xmm7 (6b)
		, 0x48, 0x8b, 0x8f, 0xa0, 0x33, 0x00, 0x00 // mov    0x33a0(%rdi),%rcx (7b)
		, 0xe8, 0x8c, 0xae, 0xb9, 0xff, 0x0f } // call   0x7ff7d24407c0 (6b)
	,	{ 0xFF, 0x15, 0x3a, 0xf7, 0xa1, 0xff }  // call qword ptr [GenerationZero_F+0x458] ( 6 bytes)
	,	NULL
	,	6 // code length
	,	19 // aob length
	}
,	[LETS_TICK]=
	{	"Move clock (Numpad 8)"
	,	{ 0x0f, 0x28, 0xce  // movaps %xmm6,%xmm1
		, 0xf3, 0x0f, 0x59, 0x8b, 0xec, 0x00, 0x00, 0x00  //  mulss  0xec(%ebx),%xmm1
		, 0xf3, 0x0f, 0x58, 0xc8 } // addss  %xmm0,%xmm1
	,	{ 0xFF, 0x15, 0xfe, 0xbe, 0xc0, 0xff 		// call qword ptr [GenerationZero_F+0x468] (6 bytes)
		, 0x90, 0x90, 0x90, 0x90, 0x90 			// nop nop nop nop nop (5 bytes)
		, 0x90, 0x90, 0x90, 0x90 }			// nop nop nop nop (4 bytes)
	,	NULL
	,	15					// tot 15 bytes
	,	15					// tot 15 bytes
	}
,	[LAST_ENTRY]=
	{	"Last entry"
	,	{ 0x00, 0x00, 0x00 }
	,	{ 0x00, 0x00, 0x00 }
	,	NULL
	,	3
	}
};


struct cheat_definition *get_definition(int cheat_id) {
	return &definitions[cheat_id];
}

